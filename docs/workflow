** This is the workflow for the berry suite of programs **

1) First a preprocessing program prepares data for further calculations (preprocessing.py)

 - scf calculation has to be done with the dft software (we will use Quantum ESPRESSO for now: needs to be in the PATH)
 - in the working directory, one needs to create a directory called 'dft' and copy to that directory the QE input file for an scf calculation and the pseudopotentials files.
 - An input file for the berry run has to be created in the running directory with several parameters defined.
	minimum parameters:
		origin of k-points
		number of k-points in each direction
		step of the k-points
		number of bands

 - with this data, the program preprocessing.py should prepare and run scf and nscf calculations.

 - After running nscf calculation, the program preprocessing.py reads the main output file and gathers data from the calculation that will be used latter, and saves it to formated files.
	Data needed to gather and save:
		*lattice dimensions
		*reciprocal lattice dimensions
		lattice vectors
		reciprocal lattice vectors
		ordered eigenvalues
		ordered list of k-points
		ordered list of occupations
		*ordered list of real space points
		total number of k-points
		number of k-points in each direction
		total number of real space points
		number of real space points in each direction

	Files creates:
		phase.npy
		neighbors.npy
		eigenvalues.npy
		occupations.npy
		positions.npy
		kpoints.npy
		datafile.npy (This is the main data file; see code for what and how data is saved)

 - Generates and saves:
		list of neighbors of each k-point (which neighbors to consider may be an input parameter)
		for each (k,r) the phase factor of the Bloch functions
	This finishes the preparatory phase.


2) Make wavefunctions coherent (generatewfc.py)

 - read wavefunctions in real space
 - choose a low symmetry point in real space and apply a phase to all wave functions so that the phase in that point is set to zero
 - save all wavefunctions

 - simply run generatewfc.py
	it will use dft.py , which then call QE program wfck2r.x to generate wfc in real space
	then it runs extractwfc.x to make the phase transformation and save new wfc 



3) Calculate the dot product of each wavefunction's Bloch factor of a k-point with each wavefunction's Bloch factor of the neighboring k-points.
 - This means wavefunctions have to be multiplied by e^{-ik.r} in each point r.

 - The python script dotproduct.py runs through wfc and calls fortran program connections.f90 to do the hard part of the calculations
	connections.f90 has to be compiled using
		py -m numpy.f2py -c connections.f90 -m connections
	in order to become a python subroutine. The resulting compile program has to be copied to a place where python can find it.
	For instance, the directory berry/python.

 - In the end we get two files dpc.dat and dp.dat
	dpc.dat contains for each pair of k-points and bands the dot product of the wavefunctions
	dp.dat contains the modulus of dpc.dat
	The files are formated as:
		kp	neighbor	band	band1	dot product-complex number (or modulus)

4) Find which eigenvalues/eigenfunctions have continuity, by running program compara.py .
 - This program reads the dot product files dp.dat and dpc.dat and uses the first to check continuity.

 - It creates two files (apontador and bandas) in the wfc directory, that will be used latter (DEPRECATED)

 - It creates two files (bandsfinal.npy and signalfinal.npy)
	The first stores an array bandsfinal[nks,nbnd] = number of band that is continuous to band in nbnd
	The second signalfinal[nks,nbnd] equals -1 if there is an inconsistency at that k-point or a number >=0
		giving the number of times it found a coninuity. The larger the value, the better.














